var documenterSearchIndex = {"docs":
[{"location":"other_modules/#Other-Modules","page":"Other Modules","title":"Other Modules","text":"","category":"section"},{"location":"other_modules/","page":"Other Modules","title":"Other Modules","text":"Other CoRaLS modules not currently in use.","category":"page"},{"location":"other_modules/#moon.jl","page":"Other Modules","title":"moon.jl","text":"","category":"section"},{"location":"other_modules/","page":"Other Modules","title":"Other Modules","text":"Models lunar geography, e.g. specific locations of permanently shadowed regions (PSRs).","category":"page"},{"location":"other_modules/#Raytrace","page":"Other Modules","title":"Raytrace","text":"","category":"section"},{"location":"other_modules/","page":"Other Modules","title":"Other Modules","text":"A raytracing version of the ray propagation model.","category":"page"},{"location":"other_modules/#Simulate_vector","page":"Other Modules","title":"Simulate_vector","text":"","category":"section"},{"location":"other_modules/","page":"Other Modules","title":"Other Modules","text":"Uses vector geometry and a mimimization routine to compute the launch angle that would cause the emergent ray to intersect the location of the spacecraft from a Direct or Reflected event.","category":"page"},{"location":"submodules_acceptance/#Modules-used-in-acceptance.jl","page":"Submodules of acceptance.jl","title":"Modules used in acceptance.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"The main sub-modules called by acceptance.jl.","category":"page"},{"location":"submodules_acceptance/#cosmic_ray.jl","page":"Submodules of acceptance.jl","title":"cosmic_ray.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Models cosmic rays and interactions. Computes depth of shower maximum (Xmax), and charge excess profile of cosmic ray-induced showers.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.charge_excess_profile-Tuple{Unitful.Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(EeV,), ùêã^2 ùêå ùêì^-2, nothing}}}","page":"Submodules of acceptance.jl","title":"CoRaLS.charge_excess_profile","text":"charge_excess_profile(Ecr::Unitful.Quantity)\n\nReturn the profile of excess shower charge (in Coulombs) for a cosmic ray of energy Ecr.\n\nThis function calculates the charge profile based on parameters derived from ZHAireS simulations of cosmic ray air showers.\n\nArguments\n\nEcr: Energy of the cosmic ray in EeV.\n\nReturns\n\nFunction Q(z) that evaluates the shower charge profile at a given distance z.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.estimate_Xmax-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.estimate_Xmax","text":"estimate_Xmax(Ecr::Unitful.Quantity)\n\nEstimate the mean and variation in Xmax for a given cosmic ray energy Ecr.\n\nXmax is the maximum depth in the atmosphere where a cosmic ray-induced air shower reaches its peak intensity. This function uses the Auger fits to Xmax and œÉ(Xmax) from:     https://www.icrc2019.org/uploads/1/1/9/0/         119067782/yushkovaugericrc2019mass1talk_final.pdf\n\nThis is only valid up to 1e20.5 (VERIFY THIS).\n\nArguments\n\nEcr: Energy of the cosmic ray in EeV.\n\nReturns\n\nTuple of (mean, sigma) of Xmax in g/cm^2.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.propagate_to_Xmax-NTuple{4, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.propagate_to_Xmax","text":"propagate_to_Xmax(origin, direction, Ecr, densitymodel)\n\nPropagate a cosmic ray from the surface to its shower maximum (Xmax).\n\nThis function calculates the point of shower maximum based on the cosmic ray's energy and direction, considering the density model of the medium through which it propagates.\n\nArguments\n\norigin: Starting point of the cosmic ray.\ndirection: Direction vector of the cosmic ray.\nEcr: Energy of the cosmic ray.\ndensitymodel: Model of the density of the medium.\n\nReturns\n\nThe position vector where the cosmic ray reaches Xmax.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#efield.jl","page":"Submodules of acceptance.jl","title":"efield.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Model and scale the electric field from a supplied cosmic ray event lookup table file.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.ARW","page":"Submodules of acceptance.jl","title":"CoRaLS.ARW","text":"The \"ARW\" model from Practical & Accurate Calculations...\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.FORTE","page":"Submodules of acceptance.jl","title":"CoRaLS.FORTE","text":"The FORTE (N. Lehtinen, PRD 2004) field model.\n\nThis requires an argument to determine what charge profile to use - currently Gaussian or GaisserHillas\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.FieldModel","page":"Submodules of acceptance.jl","title":"CoRaLS.FieldModel","text":"This type is the base for all instances of electric field models for the cosmic ray emission.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.GaisserHillasProfile","page":"Submodules of acceptance.jl","title":"CoRaLS.GaisserHillasProfile","text":"Gaisser-Hillas charge excess profile.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.GaussianProfile","page":"Submodules of acceptance.jl","title":"CoRaLS.GaussianProfile","text":"Gaussian charge excess profile.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.JAM","page":"Submodules of acceptance.jl","title":"CoRaLS.JAM","text":"The JAM field model.\n\nThis is model is wrong and should never be used for production results. The angular width is way too wide.\n\nParameterization from Alvarez-muniz et al arxiv:astro-ph/0512337 2005.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.ProfileModel","page":"Submodules of acceptance.jl","title":"CoRaLS.ProfileModel","text":"This type is the base for all longitudinal profile models.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.ARW_RE","page":"Submodules of acceptance.jl","title":"CoRaLS.ARW_RE","text":"The data file for the practical and accurate calculation.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.attenuation_length-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.attenuation_length","text":"attenuation_length(ŒΩ, n, density; tanŒ¥norm=6.5e-4)\n\nCalculate the attenuation length for radio waves in regolith at given frequencies. This function considers the refractive index and density of the regolith, as well as the loss tangent, to estimate how far radio waves can travel before being significantly attenuated.\n\nArguments\n\nŒΩ: Array of frequencies.\nn: Refractive index of the medium.\ndensity: Density of the medium.\ntanŒ¥norm: Normalized loss tangent (default: 6.5e-4).\n\nReturns\n\nArray of attenuation lengths corresponding to each frequency.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.load_ARW-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.load_ARW","text":"load_ARW()\n\nLoad the ARW (Askaryan Radio Wave) electric field data and construct an interpolator for the electric field. This function is responsible for reading the ARW data from a file and setting up a linear interpolation model for later use in electric field calculations.\n\nReturns\n\nA function that takes an angle (Œ∏) and frequency (ŒΩ) and returns the interpolated electric field value.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_field-Tuple{ARW, Vararg{Any, 4}}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_field","text":"regolith_field(::ARW, Ecr, Œ∏, Drego, Dvacuum; kwargs...)\n\nCalculate the integrated electric field at the payload using the ARW model. This function takes into account the cosmic ray energy, viewing angle, and distances through regolith and vacuum to compute the electric field.\n\nArguments\n\nEcr: Energy of the cosmic ray.\nŒ∏: Viewing angle.\nDrego: Distance through regolith.\nDvacuum: Distance through vacuum.\nkwargs: Additional keyword arguments for fine-tuning the model.\n\nReturns\n\nTuple of frequencies and corresponding electric field values.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_field-Tuple{JAM, Vararg{Any, 4}}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_field","text":"regolith_field(::JAM, Ecr, Œ∏,\n                    Drego, Dvacuum;\n                    n = sqrt(2.8), ŒΩ_min=30.0MHz, ŒΩ_max=300.0MHz, dŒΩ=10.0MHz,\n                    Latten = 35.0m)\n\nCalculate the integrated electric field at the payload using the JAM model.\n\nDo not use this - this vastly overestimates the width of the \"beam\", and allows significantly more events to pass.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#fresnel.jl","page":"Submodules of acceptance.jl","title":"fresnel.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Computes fresnel coefficients and wave divergence at the surface.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.DivergenceModel","page":"Submodules of acceptance.jl","title":"CoRaLS.DivergenceModel","text":"Abstract type for a divergence model for surface refraction.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.FarFieldDivergence","page":"Submodules of acceptance.jl","title":"CoRaLS.FarFieldDivergence","text":"Far-field (spherical) divergence.\n\nThis is taken from the FORTE paper.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.MixedFieldDivergence","page":"Submodules of acceptance.jl","title":"CoRaLS.MixedFieldDivergence","text":"Somewhere between near- and far- field divergence.\n\nThis is currently approximated by an additional sqrt(n) factor out front of the far-field (spherical) divergence.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.NearFieldDivergence","page":"Submodules of acceptance.jl","title":"CoRaLS.NearFieldDivergence","text":"Near-field (cylindrical) divergence.\n\nThis is currently approximated by an additional n factor out front of the far-field (spherical) divergence.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.divergence_tpar-Tuple{FarFieldDivergence, Vararg{Any, 4}}","page":"Submodules of acceptance.jl","title":"CoRaLS.divergence_tpar","text":"divergence_tpar(Œ∏_i, n, Drego, Dvacuum)\n\nCalculate modified Fresnel transmission coefficients for the parallel polarization, considering far-field (spherical) divergence of waves at the surface.\n\n    # Arguments\n    - `Œ∏_i`: Incident angle.\n    - `n`: Refractive index of the medium.\n    - `Drego`: Distance through regolith.\n    - `Dvacuum`: Distance through vacuum.\n\nNote: We construct this so that it can be directly multiplied to an electric field, so have to back out the total distance, before doing the scaling.\n\nNote: Since the refraction occurs in the near field (Fresnel region), the standard far-field (i.e. spherical) divergence assumption in the FORTE paper doesn't hold. Our current model for this is an additional factor of n (which boosts the transmission).\n\nSee the FORTE paper, Appendix 2, for more details. arXiV:0309656\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.divergence_tperp-Tuple{FarFieldDivergence, Vararg{Any, 4}}","page":"Submodules of acceptance.jl","title":"CoRaLS.divergence_tperp","text":"divergence_tperp(::FarFieldDivergence, Œ∏_i, n, Drego, Dvacuum)\n\nCalculate modified Fresnel transmission coefficients for the perpendicular polarization, considering far-field (spherical) divergence of waves at the surface.\n\nArguments\n\nŒ∏_i: Incident angle.\nn: Refractive index of the medium.\nDrego: Distance through regolith.\nDvacuum: Distance through vacuum.\n\nReturns\n\nModified Fresnel transmission coefficient for perpendicular polarization.\n\nNote: We construct this so that it can be directly multiplied to an electric field, so have to back out the total distance, before doing the scaling.\n\nNote: Since the refraction occurs in the near field (Fresnel region), the standard far-field (i.e. spherical) divergence assumption in the FORTE paper doesn't hold. Our current model for this is an additional factor of n (which boosts the transmission).\n\nSee the FORTE paper, Appendix 2, for more details. arXiV:0309656\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.fresnel_coeffs-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.fresnel_coeffs","text":"fresnel_coeffs(Œ∏i, ni, nt; simple_t = true)\n\nCalculate the parallel and perpendicular Fresnel reflection and transmission  coefficients. \n\nEach coefficient is the ratio of reflected/transmitted to incident amplitude (denoted r and t, not to be confused with fresnel coefficients for power, R and T)\n\nIf simplet is true (default) then the transmission coefficients are calculated as follows, otherwise they use the full Fresnel equations.     tparallel = ni * (rparallel + 1) / nt     tperpendicular = r_perpendicular + 1\n\nArguments\n\nŒ∏i: Incident angle.\nni: Refractive index of the initial medium.\nnt: Refractive index of the transmitting medium.\n\nReturns\n\n(rpar, rperp, tpar, tperp): Fresnel coefficients.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.fresnel_critical-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.fresnel_critical","text":"fresnel_critical(ni, nt)\n\nCalculate the critical angle for total internal reflection.\n\nArguments\n\nni: Refractive index of the initial medium.\nnt: Refractive index of the transmitting medium.\n\nReturns\n\nCritical angle for total internal reflection.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.snell_Œ∏t-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.snell_Œ∏t","text":"Œ∏t(Œ∏i, ni, nt)\n\nCalculate the transmitted angle from Snell's Law.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#geometry.jl","page":"Submodules of acceptance.jl","title":"geometry.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Model the geometry of the Moon and local","category":"page"},{"location":"submodules_acceptance/#CoRaLS.cartesian_to_latlon-Tuple{StaticArraysCore.SVector{3}}","page":"Submodules of acceptance.jl","title":"CoRaLS.cartesian_to_latlon","text":"Convert a cartesian point (x, y, z) into (lat, lon).\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.cartesian_to_latlonalt-Tuple{StaticArraysCore.SVector{3}}","page":"Submodules of acceptance.jl","title":"CoRaLS.cartesian_to_latlonalt","text":"Helper function to convert orbital position (x, y, z) to (lat, lon, altitude).\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.cartesian_to_spherical-Tuple{StaticArraysCore.SVector{3}}","page":"Submodules of acceptance.jl","title":"CoRaLS.cartesian_to_spherical","text":"Convert a cartesian point (x, y, z) into a spherical point (theta, phi, r).\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.horizon_angle-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.horizon_angle","text":"horizon_angle(altitude; R=Rmoon)\n\nCalculate the angle below the horizontal of the horizon from a given altitude.\n\nThis returns \"negative\" angles, in radians, for \"below\" the horizontal.\n\nArguments\n\nheight: The altitude above the surface (with units).`\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.intersect_with_sphere-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.intersect_with_sphere","text":"intersect_with_sphere(start, direction, radius)\n\nPropagate a vector from start to radius along direction.\n\nAssumes direction is normalized.\n\nSee the below link for the formalism behind this implementation:     https://www.scratchapixel.com/lessons/3d-basic-rendering/         minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.latlon_to_cartesian-Tuple{Float64, Float64}","page":"Submodules of acceptance.jl","title":"CoRaLS.latlon_to_cartesian","text":"Convert a (lat, lon) to cartesian (x, y, z) vector at radius r.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.parse_orbit","page":"Submodules of acceptance.jl","title":"CoRaLS.parse_orbit","text":"parse_orbit(fname)\n\nParse orbital info from a CSV file with columns: time, longitude, latitude, altitude.\n\nReturns SampledOrbit matrix of lon,lat,alt positions to randomly sample.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.propagate_and_refract-NTuple{5, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.propagate_and_refract","text":"propagate_and_refract(start, antenna, direction, scale, indexmodel)\n\nPropagate from start along direction to antenna, refracting at the surface.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_angles_on_cap-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_angles_on_cap","text":"Generate a (theta, phi) pair on a spherical cap uniformly in solid angle.\n\nAll angles are in radians.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_direction","page":"Submodules of acceptance.jl","title":"CoRaLS.random_direction","text":"random_direction()\n\nGenerate a random Cartesian direction distributed uniformly on the unit-sphere with the pole of the sphere aligned with normal weighted by cos^2(\theta)\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.random_north_pole_point-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_north_pole_point","text":"random_north_pole_point()\n\nDraw a random point on the North lunar pole\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_point_on_cap-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_point_on_cap","text":"Sample a random point on a spherical cap uniformly in solid angle.\n\nWe assume that the spherical cap is centered on the +z-pole of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_point_on_cicular_orbit","page":"Submodules of acceptance.jl","title":"CoRaLS.random_point_on_cicular_orbit","text":"Return cartesian vector to spacecraft at altitude.\n\nNote: this samples uniformly in latitude which does not give uniformly distributed points on the sphere (overdensity of points on the poles which  is expected for circular polar orbits).\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.random_point_on_elliptical_orbit","page":"Submodules of acceptance.jl","title":"CoRaLS.random_point_on_elliptical_orbit","text":"Return cartesian vector to spacecraft at altitude.\n\nNote: this samples uniformly in latitude which does not give uniformly distributed points on the sphere (overdensity of points on the poles which  is expected for circular polar orbits).\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.random_point_on_elliptical_orbit-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_point_on_elliptical_orbit","text":"random_point_on_elliptical_orbit(periapse, apoapse, inclination; rbody=Rmoon)\n\nReturn cartesian vector to spacecraft on an elliptical orbit.\n\nParameters:\n\nperiapse: minimum altitude above reference body surface\napoapse: maximum altitude above reference body surface\ninclination: orbital inclination in degrees\nrbody: radius of the central body (default: Rmoon)\n\nNote: This samples uniformly in true anomaly which gives a non-uniform distribution of points along the orbit (points are more densely distributed near periapse than apoapse, which is physically correct for constant angular momentum).\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_point_on_sphere","page":"Submodules of acceptance.jl","title":"CoRaLS.random_point_on_sphere","text":"random_point_on_sphere()\n\nReturn cartesian point (x, y, z) randomly distributed on sphere of radius r.\n\nThis uses the triple gaussian method which is slightly faster than the  spherical coords method. https://mathworld.wolfram.com/SpherePointPicking.html\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.random_south_pole_point-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_south_pole_point","text":"random_south_pole_point()\n\nDraw a random point on the South lunar pole\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_vector","page":"Submodules of acceptance.jl","title":"CoRaLS.random_vector","text":"random_vector()\n\nGenerate a random Cartesian direction distributed uniformly on the unit-sphere with the pole of the sphere aligned with normal\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.rotate_vector_to_align-Tuple{StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}}","page":"Submodules of acceptance.jl","title":"CoRaLS.rotate_vector_to_align","text":"rotate_vector_to_align(vec, from, to)\n\nRotate vec so that the direction from is aligned with to. If from and to are already aligned, returns vec unchanged. Numerically stable for nearly parallel vectors.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.spherical_cap_area","page":"Submodules of acceptance.jl","title":"CoRaLS.spherical_cap_area","text":"spherical_cap_area(theta, r)\n\nArea of a spherical cap with central angle theta and radius r.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.spherical_to_cartesian-Tuple{Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.spherical_to_cartesian","text":"Convert a spherical point (theta, phi, r) into Cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#ice.jl","page":"Submodules of acceptance.jl","title":"ice.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Models interactions of the RF signal with a variably rough ice layer.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.GaussianIceRoughness","page":"Submodules of acceptance.jl","title":"CoRaLS.GaussianIceRoughness","text":"GaussianIceRoughness(œÉ::typeof(0.0cm)) <: IceRoughnessModel\n\nA model representing Gaussian ice surface roughness, characterized by a standard deviation (œÉ) of the angular distribution of the surface.\n\nArguments\n\nœÉ: Standard deviation of the surface angles, representing the degree of roughness.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.IceRoughnessModel","page":"Submodules of acceptance.jl","title":"CoRaLS.IceRoughnessModel","text":"ice.jl\n\nModels the surface roughness of ice, which is a critical factor in simulating the reflection and transmission of radio waves on ice surfaces. It includes abstract and concrete types representing different models of ice roughness and functions to apply these models to simulated electric fields.\n\nMain Components\n\nIceRoughnessModel: An abstract type for general ice roughness models.\nNoIceRoughness: A model representing no surface roughness (smooth ice).\nGaussianIceRoughness: A model representing Gaussian ice surface roughness, characterized by a standard deviation of surface angles.\nice_roughness: Functions to apply roughness models to electric fields, modifying them based on the specified roughness model.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.NoIceRoughness","page":"Submodules of acceptance.jl","title":"CoRaLS.NoIceRoughness","text":"NoIceRoughness <: IceRoughnessModel\n\nRepresents a model of ice surface with no roughness (smooth surface). This model assumes a perfectly smooth ice surface, affecting the reflection and transmission of radio waves accordingly.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.ice_roughness-Tuple{NoIceRoughness, Any, Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.ice_roughness","text":"ice_roughness(model::IceRoughnessModel, ŒΩ, E, Œ∏_i)\n\nApply the specified ice roughness model to a simulated electric field. The function modifies the electric field based on the roughness characteristics of the model.\n\nArguments\n\nmodel: An instance of IceRoughnessModel to apply.\nŒΩ: Frequencies of the electric field.\nE: Electric field amplitudes.\nŒ∏_i: Angle of incidence at the ice surface.\n\nReturns\n\nModified frequencies and electric field based on the roughness model. If the model is NoIceRoughness, the function returns the given frequencies and electric field. If the model is GaussianIceRoughness, the function modifies the electric field based on the \"Diffuse reflection by rough surfaces: an introduction\" by Sylvain, Pg. 671.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#regolith.jl","page":"Submodules of acceptance.jl","title":"regolith.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Models the lunar regolith and propagation of RF signal through it.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.CE3Index","page":"Submodules of acceptance.jl","title":"CoRaLS.CE3Index","text":"Chang'E-3 regolith index \n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.CE4Index","page":"Submodules of acceptance.jl","title":"CoRaLS.CE4Index","text":"Chang'E-4 regolith index \n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.ConstantDensity","page":"Submodules of acceptance.jl","title":"CoRaLS.ConstantDensity","text":"Constant regolith density\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.ConstantIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.ConstantIndex","text":"Constant regolith refractive index.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.DivinerIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.DivinerIndex","text":"Diviner regolith index \n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.LunarSourceBookIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.LunarSourceBookIndex","text":"Lunar Source Book regolith index \n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.OldIncorrectDensity","page":"Submodules of acceptance.jl","title":"CoRaLS.OldIncorrectDensity","text":"A logarithmic regolith density model from PG's ARIA MC.\n\nThis is WRONG - do NOT use this except when trying to reproduce or evaluate results from early August 2021.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.RegolithDensity","page":"Submodules of acceptance.jl","title":"CoRaLS.RegolithDensity","text":"Abstract type for regolith density models.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.RegolithIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.RegolithIndex","text":"Abstract type for regolith index models.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.StrangwayDensity","page":"Submodules of acceptance.jl","title":"CoRaLS.StrangwayDensity","text":"A regolith density model from Olhoeft & Strangway.\n\nThis is \"Curve A\" from O&S.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.StrangwayDensityCB","page":"Submodules of acceptance.jl","title":"CoRaLS.StrangwayDensityCB","text":"A regolith density model from Olhoeft & Strangway.\n\nThis is \"Curve B\" from O&S.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.StrangwayIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.StrangwayIndex","text":"A refractive index model from Olhoeft & Strangway.\n\nThis uses Eq. 1 from Olhoeft and Strangway. (1975)\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.StrangwayIndexCB","page":"Submodules of acceptance.jl","title":"CoRaLS.StrangwayIndexCB","text":"Olhoeft and Strangway Curve B regolith index (1975)\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.SurfaceDeepIndex","page":"Submodules of acceptance.jl","title":"CoRaLS.SurfaceDeepIndex","text":"A \"surface\" and \"deep\" regolith model.\n\nThis uses a small refractive index at the surface and a larger one for below the surface.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.create_density_lut","page":"Submodules of acceptance.jl","title":"CoRaLS.create_density_lut","text":"create_density_lut(N)\n\nCreate a LUT of the density as a function of depth using \"Curve A\" from Olhoeft & Strangway. N is the number of points in the LUT.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.create_density_lut-2","page":"Submodules of acceptance.jl","title":"CoRaLS.create_density_lut","text":"create_density_lut(N)\n\nCreate a LUT of the density as a function of depth using \"Curve B\" from Olhoeft & Strangway. N is the number of points in the LUT.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.regolith_density-Tuple{CE3LPRDensity, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::CE3LPRDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_density-Tuple{CoRaLS.OldIncorrectDensity, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::OldIncorrectDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_density-Tuple{ConstantDensity, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::ConstantDensity, depth)\n\nCalculate the density of the regolith in g/cm^3.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_density-Tuple{StrangwayDensity, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::StrangwayDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth using the Olhoeft & Strangway curve.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_density-Tuple{StrangwayDensityCB, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::StrangwayDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth using the Olhoeft & Strangway curve.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_index","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_index","text":"regolith_index(::IndexModel, depth, low_temp_corr_factor=0.9)\n\nA refractive index model from Olhoeft & Strangway.\n\nDielectric constant fit is done by Olhoeft and Strangway Peter estimated a 10% reduction for lunar PSR's due to the ~80 K temperatures compared to the typical lunar temperatures of O&S, hence the lowtempcorr_factor.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.regolith_index-Tuple{ConstantIndex, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_index","text":"regolith_index(::ConstantIndex, depth)\n\nA constant refractive index as a function of depth.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.regolith_index-Tuple{SurfaceDeepIndex, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.regolith_index","text":"regolith_index(::SurfaceDeepIndex, depth)\n\nA two-part \"surface\" and \"deep\" refractive index model.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#spectrum.jl","page":"Submodules of acceptance.jl","title":"spectrum.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Cosmic ray spectrum (AUGER) calculations.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.auger_spectrum-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.auger_spectrum","text":"Randomly evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1 within experimental uncertainties.\n\nThis method differs from the one argument version of auger_spectrum() in that it randomly samples the parameters within experimental uncertainties so that you can capture the variation in the cosmic ray spectrum.\n\nThis uses the parameterization from:     https://academic.oup.com/ptep/article/2017/12/12A103/4665686\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.auger_spectrum-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.auger_spectrum","text":"Evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1.\n\nThis uses the parameterization from:     https://academic.oup.com/ptep/article/2017/12/12A103/4665686\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.auger_spectrum_2020-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.auger_spectrum_2020","text":"Evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1.\n\nValid for 10^18 to ~10^20 eV.\n\nSee Equation 9 in:     Measurement of the cosmic-ray energy spectrum above 2.5e18 eV using the      Pierre Auger Observatory. Phys.Rev.D (2020)      https://doi.org/10.1103/PhysRevD.102.062005\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.auger_spectrum_2021-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.auger_spectrum_2021","text":"Evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1.\n\nValid for 10^17 to ~10^20 eV.\n\nSee Equation 9 in: Abreu, P., Aglietta, M., Albury, J.M. et al. The energy spectrum of cosmic rays  beyond the turn-down around 10^17 eV as measured with the surface detector of  the Pierre Auger Observatory. Eur. Phys. J. C 81, 966 (2021).  https://doi.org/10.1140/epjc/s10052-021-09700-w\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.sample_auger-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.sample_auger","text":"sample_auger(min_energy, max_energy)\n\nDraw a random sample from the Auger UHECR flux between min_energy and max_energy.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.sample_power_law-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.sample_power_law","text":"sample_power_law(gamma, N; min_value, max_value)\n\nDraw N random samples from a power law with exponent gammma.\n\nIf provided, min_value and max_value set the range over which the power-law is sampled (defaults to 1 EeV and 1000 EeV)\n\nThis uses the prescription from:     https://mathworld.wolfram.com/RandomNumber.html to convert a uniform deviate into a power law with a given exponent.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.sample_power_law-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.sample_power_law","text":"sample_power_law(gamma; min_value, max_value)\n\nDraw random samples from a power law with exponent gammma.\n\nIf provided, min_value and max_value set the range over which the power-law is sampled (defaults to 1 EeV and 1000 EeV)\n\nThis uses the prescription from:     https://mathworld.wolfram.com/RandomNumber.html to convert a uniform deviate into a power law with a given exponent.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#surface.jl","page":"Submodules of acceptance.jl","title":"surface.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Models surface roughness and slope, including generating random surface normals and calculating surface transmission.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.GaussianRoughness","page":"Submodules of acceptance.jl","title":"CoRaLS.GaussianRoughness","text":"Gaussian surface roughness model.\n\nThis is characterized by Gaussian \"sigma\" of the angular distribution of the surface.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.GaussianSlope","page":"Submodules of acceptance.jl","title":"CoRaLS.GaussianSlope","text":"Gaussian surface slope model.\n\nThis is characterized by Gaussian \"sigma\" of the angular distribution of the surface in degrees.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.NoRoughness","page":"Submodules of acceptance.jl","title":"CoRaLS.NoRoughness","text":"No surface roughness (smooth)\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.NoSlope","page":"Submodules of acceptance.jl","title":"CoRaLS.NoSlope","text":"No surface slope (smooth)\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.RoughnessModel","page":"Submodules of acceptance.jl","title":"CoRaLS.RoughnessModel","text":"Abstract type for regolith surface roughness model.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.SlopeModel","page":"Submodules of acceptance.jl","title":"CoRaLS.SlopeModel","text":"Abstract type for regolith surface slope model.\n\n\n\n\n\n","category":"type"},{"location":"submodules_acceptance/#CoRaLS.random_surface_normal-Tuple{GaussianSlope, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_surface_normal","text":"random_surface(slope::GaussianSlope, normal)\n\nGenerate a random normal vector for a surface slope that would originally be pointing along normal in the absence of roughness.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.random_surface_normal-Tuple{NoSlope, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.random_surface_normal","text":"random_surface(slope::NoSlope, normal)\n\nGenerate a random normal vector for a surface slope that would originally be pointing along normal in the absence of roughness.\n\nThis just returns normal since this implements a \"No Slope\" model.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.surface_transmission-Tuple{GaussianRoughness, Any, Any, Any, Vararg{Any}}","page":"Submodules of acceptance.jl","title":"CoRaLS.surface_transmission","text":"surface_transmission(::GaussianRoughness, ŒΩ, E, Œ∏_i)\n\nApply a simple model for surface transmission through a rough surface by taking the average of the transmission coefficient over the Gaussian\n\nThis is based on the \"Diffuse reflection by rough surfaces: an introduction\" by Sylvain, Pg. 671\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.surface_transmission-Tuple{NoRoughness, Any, Any, Any, Vararg{Any}}","page":"Submodules of acceptance.jl","title":"CoRaLS.surface_transmission","text":"surface_transmission(::NoRoughness, ŒΩ, E, Œ∏_i)\n\nApply roughness to a simulated electric field given the frequencies, the electric field, and the angle of incidence at the surface. This returns the frequencies and electric field back to the caller.\n\nWithout roughness, we just return ŒΩ and E as given.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#trigger.jl","page":"Submodules of acceptance.jl","title":"trigger.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Simple triggers for cosmic ray detection.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.gaussian_trigger","page":"Submodules of acceptance.jl","title":"CoRaLS.gaussian_trigger","text":"gaussian_trigger(peak=67ŒºV/m, œÉ=45.0; dŒΩ=10.0MHz, Œ∏0=-90.)\n\nCreates a Gaussian beam threshold pointing down towards the nadir     with peak threshold at the nadir and a width of œÉ in degrees. This uses the current estimate for a sinuous antenna array by P. Gorham\n\nArguments\n\npeak=67ŒºV/m: Peak threshold of the electric field at the nadir.\nœÉ=45.0: Width of the Gaussian beam in degrees.\ndŒΩ=10.0MHz: Frequency step size.\nŒ∏0=-90.: Nadir angle in degrees.\n\nReturns\n\nA function that checks if an event's electric field, after being scaled by a Gaussian factor based on its off-axis angle, exceeds the peak threshold.\n\nDescription\n\nThis trigger function incorporates a Gaussian beam pattern, scaling the threshold for the electric field magnitude based on the event's off-axis angle relative to the nadir. The Gaussian factor decreases the effective threshold as the angle increases from the nadir.\n\nUsage\n\nUseful in scenarios where the sensitivity of detection varies with the angle of incident cosmic rays, simulating a realistic antenna response.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.magnitude_trigger","page":"Submodules of acceptance.jl","title":"CoRaLS.magnitude_trigger","text":"magnitude_trigger(peak=67ŒºV/m; dŒΩ=10.0MHz)\n\nCreate a trigger function that checks if the total magnitude of the electric field is greater than some threshold.\n\nArguments\n\npeak=67ŒºV/m: The threshold for the electric field's magnitude.\ndŒΩ=10.0MHz: Frequency step size.\n\nReturns\n\nA function that checks if the norm of the electric field of an event is greater than the threshold.\n\nDescription\n\nThis function generates a trigger function that evaluates whether the total magnitude of the electric field for a cosmic ray event exceeds a specified threshold. The electric field magnitude is calculated as the product of the field's polarization norm, frequency step size, and sum of electric field components.\n\nUsage\n\nUsed to filter events based on the strength of their electric field magnitude, allowing selection of significant cosmic ray events.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#CoRaLS.rician_trigger-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.rician_trigger","text":"rician_trigger(;snr_threshold=5.0, bw=900.0MHz, peak=calculated, œÉ=45.0)\n\nCreate a Rician beam trigger function based on signal-to-noise ratio.\n\nParameters\n\nsnr_threshold=5.0: The signal-to-noise ratio threshold for triggering.\nbw=900.0MHz: Bandwidth for the trigger.\npeak=calculated: Peak threshold calculated based on the provided parameters.\nœÉ=45.0: Width of the Gaussian beam in degrees.\n\nReturns\n\nA trigger function that evaluates if the signal-to-noise ratio of an event's electric field exceeds the specified threshold.\n\nDescription\n\nThis trigger function calculates a scaled threshold based on the event's off-axis angle and evaluates if the event's electric field, subjected to a Rician distributed noise model, surpasses this threshold. The function accounts for both primary and subsurface reflections.\n\nUsage\n\nIdeal for more sophisticated detection scenarios where the signal-to-noise ratio plays a crucial role in determining event significance.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.trigger_all-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.trigger_all","text":"trigger_all()\n\nAlways triggers. Used for testing geometric acceptance and debugging.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#detector.jl","page":"Submodules of acceptance.jl","title":"detector.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Detector models for complex triggering with antennas and SNR levels.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.ANITA-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.ANITA","text":"ANITA(;kwargs...)\n\nCreate a model for the ANtarctic Impulsive Transient Antenna (ANITA) used in cosmic ray detection simulations. Configures the ANITA system based on given parameters or defaults.\n\nKeyword Arguments\n\nkwargs: Parameters for the ANITA model, including frequency range and other antenna-specific settings.\n\nReturns\n\nA configured ANITA antenna model.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.LPDA-Tuple{}","page":"Submodules of acceptance.jl","title":"CoRaLS.LPDA","text":"LPDA(;kwargs...)\n\nCreate a model for the Low-Profile Dipole Array (LPDA) used in cosmic ray detection simulations. Configures the LPDA based on given parameters or defaults.\n\nKeyword Arguments\n\nkwargs: Parameters for the LPDA model, such as altitude, frequency range, and noise settings.\n\nReturns\n\nA configured LPDA antenna model.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.create_antenna-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.create_antenna","text":"create_antenna(fname, skyfrac; kwargs...)\n\nConstruct an antenna-factor based antenna simulation. This function sets up the parameters for an antenna system, including its frequency range, noise characteristics, and response factors, based on antenna factor data from a file.\n\nArguments\n\nfname: Filename containing antenna factor data.\nskyfrac: Fraction of the antenna's view that is sky.\nkwargs: Additional keyword arguments including altitude, frequency range, angular resolutions, and trigger settings.\n\nReturns\n\nA function that evaluates the antenna trigger condition for a given event.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#Sky","page":"Submodules of acceptance.jl","title":"Sky","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Computes the sky temperature for noise calculations in detector.jl.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.extragalactic_noise-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.extragalactic_noise","text":"extragalactic_noise(ŒΩ)\n\nCalculate the extragalactic contribution to RF background noise  (in W m^-2 Hz^-1 sr^-1) as function of frequency (in MHz) near the galactic poles.\n\nArguments\n\nŒΩ: Frequency at which the extragalactic noise is to be calculated.\n\nReturns\n\nThe extragalactic noise in W m^-2 Hz^-1 sr^-1.\n\nDescription\n\nThis function estimates the extragalactic noise contribution based on the frequency. It uses a parameterization taken from Dulk (2001), specifically tailored for observations near the galactic poles:     https://www.aanda.org/articles/aa/full/2001/02/aads1858/aads1858.right.html\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.galactic_noise-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.galactic_noise","text":"galactic_noise(ŒΩ)\n\nCalculate the galactic contribution to RF background noise as function of frequency near the galactic poles.\n\nArguments\n\nŒΩ: Frequency at which the galactic noise is to be calculated.\n\nReturns\n\nThe galactic noise in W m^-2 Hz^-1 sr^-1.\n\nDescription\n\nThis function computes the galactic noise component of the RF background. The calculation is based on a model from Dulk (2001):     https://www.aanda.org/articles/aa/full/2001/02/aads1858/aads1858.right.html\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.sky_temperature-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.sky_temperature","text":"sky_temperature(ŒΩ)\n\nCalculate the brightness temperature near the galactic poles as a function of frequency.\n\nArguments\n\nŒΩ: Frequency at which the sky temperature is to be calculated.\n\nReturns\n\nThe brightness temperature near the galactic poles in Kelvin.\n\nDescription\n\nThis function calculates the combined extragalactic and galactic noise contributions to the radio frequency background and converts it into a brightness temperature. This temperature is a crucial parameter in astrophysical studies, especially when analyzing cosmic ray interactions and detections near the galactic poles.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#utils.jl","page":"Submodules of acceptance.jl","title":"utils.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Miscellaneous utilities.","category":"page"},{"location":"submodules_acceptance/#CoRaLS.polarization_angle-Tuple{Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.polarization_angle","text":"polarization_angle(events)\n\nCalculate the polarization angle for a given set of events.\n\nArguments\n\nevents: A collection of event data, each with a polarization vector.\n\nReturns\n\nAn array of polarization angles in degrees.\n\nDescription\n\nThis function computes the polarization angle for each event in the provided collection. The polarization angle is calculated relative to the horizontal plane of the antenna array, with 0 degrees corresponding to horizontal polarization and 90 degrees to vertical polarization.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.retrigger-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.retrigger","text":"retrigger(AŒ©, trig)\n\nRecalculate the effective acceptance for direct and reflected events.\n\nArguments\n\nAŒ©: A struct holding initial acceptance calculation results.\ntrig: A trigger function used to reassess event acceptance.\n\nReturns\n\nA tuple containing the recalculated effective acceptances for direct and reflected events.\n\nDescription\n\nThis function applies a new trigger to a set of cosmic ray events, recalculating the effective acceptance based on which events would pass this new trigger. It's useful for assessing the impact of different trigger criteria on event detection rates.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.rician","page":"Submodules of acceptance.jl","title":"CoRaLS.rician","text":"rician(ŒΩ, œÉ, N = 1)\n\nDraw one or more Rician random variables.\n\nArguments:\n\nŒΩ: The noncentrality parameter, can be a scalar or an array.\nœÉ: The scale parameter, can be a scalar or an array matching the size of ŒΩ.\nN = 1: The number of samples to draw. Used only if ŒΩ is a scalar.\n\nReturns\n\nIf ŒΩ and œÉ are single values, it returns a single Rician random variable.\nIf ŒΩ and œÉ are arrays, it returns an array of Rician random variables with each element corresponding to elements in ŒΩ and œÉ.\nIf ŒΩ is a single value and N > 1, it returns an array of N Rician random variables, all generated with the same ŒΩ and œÉ.\n\n\n\n\n\n","category":"function"},{"location":"submodules_acceptance/#plots.jl","page":"Submodules of acceptance.jl","title":"plots.jl","text":"","category":"section"},{"location":"submodules_acceptance/","page":"Submodules of acceptance.jl","title":"Submodules of acceptance.jl","text":"Visualization Tools for CoRaLS Simulation Data","category":"page"},{"location":"submodules_acceptance/#CoRaLS.mcse-Tuple{Int64, Int64}","page":"Submodules of acceptance.jl","title":"CoRaLS.mcse","text":"mcse(count, ntrials, [gAŒ©])\n\nCompute the Monte Carlo Standard Error as count or acceptance if gAŒ© is given.\n\nUses Monte Carlo Standard Error for binomial proportion: sqrt(p*(1-p)/n)\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_acceptance-Tuple{Union{CoRaLS.Acceptance, CoRaLS.OldAcceptance}}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_acceptance","text":"plot_acceptance(AŒ©::Acceptance)\n\nPlot the direct and reflected acceptance of the CoRaLS project.\n\nArguments:\n\nAŒ©::Acceptance: An object containing the acceptance calculation results.\n\nThis function generates a line plot illustrating the acceptance rates for both direct and reflected events across different energy levels.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_differential_spectrum-Tuple{Union{CoRaLS.Acceptance, CoRaLS.OldAcceptance}, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_differential_spectrum","text":"plot_differential_spectrum(AŒ©::Acceptance, T::Unitful.Time)\n\nCreate a plot of the differential event spectrum of CoRaLS events given an acceptance object and a mission duration.\n\nArguments:\n\nAŒ©::Acceptance: An object containing the acceptance calculation results.\nT::Unitful.Time: The total observation time of the experiment.\n\nThis function plots the estimated number of events per energy bin over the duration of the mission.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_incident_angles-Tuple{Union{CoRaLS.Acceptance, CoRaLS.OldAcceptance}}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_incident_angles","text":"plot_incident_angles(AŒ©::Acceptance)\n\nPlot the incident angles at the ice and the surface for both direct and reflected events, along with the corresponding Fresnel coefficients.\n\nArguments:\n\nAŒ©::Acceptance: An object containing the acceptance calculation results.\n\nGenerates a two-part plot. The left plot shows histograms of incident angles at the surface for direct and reflected events. The right plot shows incident angles at the ice layer for reflected events. Behind these histograms, the function plots the transmission and reflection coefficients as a function of the incident angle.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_offaxis_angle-Tuple{Union{CoRaLS.Acceptance, CoRaLS.OldAcceptance}}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_offaxis_angle","text":"plot_offaxis_angle(AŒ©::Acceptance)\n\nGenerate a plot showing the off-axis angle distribution of direct and reflected events in the CoRaLS simulations.\n\nArguments:\n\nAŒ©::Acceptance: An object containing the acceptance calculation results.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_polarization_angle-Tuple{Union{CoRaLS.Acceptance, CoRaLS.OldAcceptance}}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_polarization_angle","text":"plot_polarization_angle(AŒ©::Acceptance)\n\nPlot histograms of polarization angles for direct and reflected events.\n\nArguments:\n\nAŒ©::Acceptance: An object containing the acceptance calculation results.\n\n\n\n\n\n","category":"method"},{"location":"submodules_acceptance/#CoRaLS.plot_rate_experiment-Tuple{Any, Any}","page":"Submodules of acceptance.jl","title":"CoRaLS.plot_rate_experiment","text":"plot_rate_experiment(AŒ©::Acceptance, xs; xlabel)\n\nPlot the counts in events / yr for an array of acceptance runs computed at some variable x (e.g., ice depths, altitudes).\n\nArguments:\n\nAŒ©s : Array of acceptance objects.\nxs : Array of paramter values for the x axis corresponding to each AŒ©.\n\nThis function plots the estimated number of events per energy bin over the duration of the mission.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#simulate.jl:-Main-Cosmic-Ray-Simulation","page":"simulate.jl: Main Cosmic Ray Simulation","title":"simulate.jl: Main Cosmic Ray Simulation","text":"","category":"section"},{"location":"simulate_jl/","page":"simulate.jl: Main Cosmic Ray Simulation","title":"simulate.jl: Main Cosmic Ray Simulation","text":"The simulate.jl module simulates cosmic ray events and progates the RF signal through the regolith.","category":"page"},{"location":"simulate_jl/#CoRaLS.AbstractSignal","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.AbstractSignal","text":"Abstract type for simulated signals, both direct and reflected.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.Direct","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.Direct","text":"The information stored for a direct RF detection.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.EventGeometry","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.EventGeometry","text":"An enum for possible event geometries (i.e. direct or reflected)\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.GeometryImplementation","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.GeometryImplementation","text":"Abstract type for event simulation implementation.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.Reflected","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.Reflected","text":"The information stored for a reflected RF detection.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.ScalarGeometry","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.ScalarGeometry","text":"Approximate scalar geometry based on Andres' MC.\n\nThis makes the approximation that the CR impact point is the same as the refraction point - this is an error of order <10m out of the 30km distance to the payload.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.TrialFailed","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.TrialFailed","text":"An enum for possible reasons why the a cosmic ray trial failed.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.VectorGeometry","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.VectorGeometry","text":"3D vector geometry implementation.\n\nThis is the original method of the UH MC - there are no approximations used in this solution.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#Base.show-Tuple{IO, CoRaLS.Direct}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"Base.show","text":"Simplifiy the printing of Signal structs.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#CoRaLS.compute_direct-Tuple{ScalarGeometry, Vararg{Any, 5}}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.compute_direct","text":"Compute the 'direct' RF solution using the scalar geometry.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#CoRaLS.compute_reflected-Tuple{ScalarGeometry, Vararg{Any, 6}}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.compute_reflected","text":"Compute the 'reflected' RF solution using the scalar solution.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#CoRaLS.propagate_cosmicray-NTuple{4, Any}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.propagate_cosmicray","text":"Propagate cosmic ray into surface and compute direct and reflected RF.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#CoRaLS.throw_cosmicray-NTuple{4, Any}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.throw_cosmicray","text":"Simulate a single cosmic ray trial with a given energy.\n\nThis calculates the field at the payload for the direct and reflected emission, (if they exist) and returns whether the event triggered.\n\n\n\n\n\n","category":"method"},{"location":"simulate_jl/#CoRaLS.throw_cosmicray-Tuple{Any, Any}","page":"simulate.jl: Main Cosmic Ray Simulation","title":"CoRaLS.throw_cosmicray","text":"Simulate a single cosmic ray trial with a given energy.\n\nThis calculates the field at the payload for the direct and reflected emission, (if they exist) and returns whether the event triggered.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/#CoRaLS-Tutorial","page":"Tutorials","title":"CoRaLS Tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Coming soon.","category":"page"},{"location":"acceptance_jl/#acceptance.jl:-The-Main-Monte-Carlo-Loop","page":"acceptance.jl: Main Monte Carlo Loop","title":"acceptance.jl: The Main Monte Carlo Loop","text":"","category":"section"},{"location":"acceptance_jl/","page":"acceptance.jl: Main Monte Carlo Loop","title":"acceptance.jl: Main Monte Carlo Loop","text":"The main acceptance() loop computes many cosmic ray impacts to a supplied region of the lunar surface and observed with a chosen spacecraft and triggering method, returning an Acceptance object containing the number of detected events and final acceptance in [km^2 sr] units.","category":"page"},{"location":"acceptance_jl/#CoRaLS.Acceptance","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.Acceptance","text":"A structure to hold results of acceptance calculations, including trials, altitude, energies, and different acceptance types (direct and reflected).\n\n\n\n\n\n","category":"type"},{"location":"acceptance_jl/#CoRaLS.acceptance-Tuple{Int64, Int64}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.acceptance","text":"acceptance(ntrials, nbins; region, spacecraft, trigger, ...)\n\nCalculates the acceptance of CoRaLS for sub-surface UHECR reflections. It involves simulations of cosmic ray interactions, triggering conditions, and aggregating results across multiple trials and energy bins.\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.differential_spectrum-Tuple{Any, Any, Any}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.differential_spectrum","text":"differential_spectrum(energies, AŒ©, T)\n\nCalculate the differential spectrum of detected UHECR events based on acceptance calculations and T, the total observation time of the experiment.\n\nCalculates the differential spectrum of detected UHECR events .\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.load_acceptance-Tuple{String}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.load_acceptance","text":"load_acceptance(filename::String)::Acceptance\n\nLoad the acceptance data from a .jld2 file.\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.merge_acceptance-Tuple{CoRaLS.Acceptance, CoRaLS.Acceptance}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.merge_acceptance","text":"merge_acceptance(A::Acceptance, B::Acceptance)::Acceptance\n\nMerge two Acceptance structures into one, combining their trial counts and results.\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.old_acceptance-Tuple{Any, Any}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.old_acceptance","text":"old_acceptance(ntrials, nbins; ...)\n\nCalculates the acceptance of CoRaLS for sub-surface UHECR reflections. It involves simulations of cosmic ray interactions, triggering conditions, and aggregating results across multiple trials and energy bins.\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.save_acceptance-Tuple{CoRaLS.Acceptance, String}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.save_acceptance","text":"save_acceptance(A::Acceptance, filename::String)\n\nSave the acceptance data to a file (only .jld2 supported).\n\n\n\n\n\n","category":"method"},{"location":"acceptance_jl/#CoRaLS.trials_passed-Tuple{Any}","page":"acceptance.jl: Main Monte Carlo Loop","title":"CoRaLS.trials_passed","text":"trials_passed\n\nCalculate the number of successful trials in the direct and reflected acceptances.\n\n\n\n\n\n","category":"method"},{"location":"#CoRaLS-Documentation","page":"Getting Started","title":"CoRaLS Documentation","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Welcome to the CoRaLS documentation","category":"page"},{"location":"#CoRaLS","page":"Getting Started","title":"CoRaLS","text":"CoRaLS\n\nThe CoRaLS.jl (Cosmic Ray Lunar Sounder) Monte Carlo model computes detection rates of Askaryan emission from cosmic ray interactions in lunar regolith.\n\nInstallation\n\nInstall Julia \nInstall Python and the matplotlib package, the easiest way is with Anaconda (e.g. conda list matplotlib).\nFork or clone this repository:\n\ngit clone git@github.com:cjtu/CoRaLS.jl.git\n\n(First time only): Setup path to python/matplotlib. In the Julia REPL, supply the path to your python environment from #2 in quotes to ENV[\"PYTHON\"]=\"\" (leave blank to use system default python). Then add and build the PyCall package:\n\n$ julia\n\njulia> ENV[\"PYTHON\"]=\"\"\njulia> using Pkg\njulia> Pkg.add(\"PyCall\")\njulia> Pkg.build(\"PyCall\")\n\nRun the test suite to test the installation:\n\njulia --project=/path/to/CoRaLS.jl /path/to/CoRaLS.jl/test/runtests.jl\n\nIf the tests were successful, CoRaLS.jl is compiled and ready to use!\n\nCalculating rates with CoRaLS\n\nStart Julia with the CoRaLS project active using the --project flag pointing to the CoRaLS directory (if you are in the directory use --project=.). For multithreaded mode, use -t to specify the number of threads (default is 1, \"auto\" chooses for you).\n\njulia --project=/path/to/CoRaLS.jl -t \"auto\"\njulia> using CoRaLS\n\nimport CoRaLS with:\n\njulia> using CoRaLS\n\nCompute and plot an acceptance:\n\njulia> A = acceptance(10000, 20; region=create_region(\"psr:south\"), spacecraft=CircularOrbit(50.0km))\njulia> plot_acceptance(A)\n\nSee full documentation online at... (coming soon)\n\nDevelopers\n\nTo make and preview docs locally run the following from the root CoRaLS directory:\n\njulia --project=docs -e 'include(\"docs/make.jl\"); using LiveServer; serve(dir=\"docs/build\")'\n\nTo run tests:\n\njulia --project=. test/runtests.jl\n\nCiting\n\nPaper coming soon.\n\n\n\n\n\n","category":"module"},{"location":"#API-Index","page":"Getting Started","title":"API Index","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"","category":"page"}]
}
