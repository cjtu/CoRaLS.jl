var documenterSearchIndex = {"docs":
[{"location":"tutorials/#CoRaLS-Tutorial","page":"Tutorials","title":"CoRaLS Tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Coming soon.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This guide will walk you through the process of installing and setting up the CoRaLS simulation package.","category":"page"},{"location":"installation/#Quick-Install-Steps","page":"Installation","title":"Quick Install Steps","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"** Install Julia v1.8.**:   Since this is an older release, either go to old releases and add Julia to your system path or use an install helper like juliaup or jill.\nYou will also ensure Python and matplotlib are installed.\nClone the CoRaLS repository:  sh  git clone git@github.com:cjtu/CoRaLS.jl.git\n** Install CoraLS.jl**:  Change directory to the cloned repository. If using multiple Julia versions on this machine, you may need to specify juliaup default 1.8.5 or jill switch 1.8. Then start Julia via:\nsh  cd CoRaLS.jl  julia\nIn the Julia REPL (the interoreter that starts when you type julie, stands for read-eval-print loop), enter package mode by pressing ] (note julia> changes to >pkg). Adding and building the PyCall package will give Julia access to the Python installation specified at the path supplied in quotes to ENV[\"PYTHON\"] (leave blank \"\" to use system default python):\njulia  julia> ENV[\"PYTHON\"]=\"\"  julia> ]  pkg> add PyCall  pkg> build PyCall\nThen activate the CoRaLS environment and instantiate it to install the required packages and compile CoRaLS.jl:\njulia  pkg> activate .  pkg> instantiate\nNow CoRaLS is ready to use. To exit package mode, press backspace (prompt is now julia>). Try importing CoRaLS and running a test:\nVerify Installation:  julia  julia> using CoRaLS  julia> plot_acceptance(acceptance(10000, 20))\nOr equivalently:\njulia  julia> import CoRaLS  julia> CoRaLS.plot_acceptance(CoRaLS.acceptance(10000, 20))\nExit julia with ctrl+D or exit():\njulia  julia> exit()","category":"page"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you encounter any issues during the installation process, please refer to the FAQs or contact the simulations team.","category":"page"},{"location":"simulate_jl/#simulate.jl:-The-Main-Cosmic-Ray-Simulation-Script","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"simulate.jl: The Main Cosmic Ray Simulation Script","text":"","category":"section"},{"location":"simulate_jl/","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"simulate.jl: The Main Cosmic Ray Simulation Script","text":"simulate.jl implements various functions and types for simulating cosmic ray events and their corresponding radio frequency (RF) signals.","category":"page"},{"location":"simulate_jl/#Main-Components","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"Main Components","text":"","category":"section"},{"location":"simulate_jl/","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"simulate.jl: The Main Cosmic Ray Simulation Script","text":"CoRaLS.throw_cosmicray\nCoRaLS.compute_direct\nCoRaLS.compute_reflected\nCoRaLS.Reflected\nCoRaLS.Direct\nCoRaLS.AbstractSignal\nCoRaLS.ScalarGeometry\nCoRaLS.VectorGeometry\nCoRaLS.GeometryImplementation\nCoRaLS.EventGeometry\nCoRaLS.TrialFailed","category":"page"},{"location":"simulate_jl/#CoRaLS.throw_cosmicray","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.throw_cosmicray","text":"Simulate a single cosmic ray trial with a given energy.\n\nThis calculates the field at the payload for the direct and reflected emission, (if they exist), and does not check fo a trigger condition.\n\n\n\n\n\n","category":"function"},{"location":"simulate_jl/#CoRaLS.compute_direct","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.compute_direct","text":"Compute the 'direct' RF solution using the scalar geometry.\n\n\n\n\n\n","category":"function"},{"location":"simulate_jl/#CoRaLS.compute_reflected","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.compute_reflected","text":"Compute the 'reflected' RF solution using the scalar solution.\n\n\n\n\n\n","category":"function"},{"location":"simulate_jl/#CoRaLS.Reflected","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.Reflected","text":"The information stored for a reflected RF detection.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.Direct","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.Direct","text":"The information stored for a direct RF detection.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.AbstractSignal","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.AbstractSignal","text":"Abstract type for simulated signals, both direct and reflected.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.ScalarGeometry","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.ScalarGeometry","text":"Approximate scalar geometry based on Andres' MC.\n\nThis makes the approximation that the CR impact point is the same as the refraction point - this is an error of order <10m out of the 30km distance to the payload.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.VectorGeometry","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.VectorGeometry","text":"3D vector geometry implementation.\n\nThis is the original method of the UH MC - there are no approximations used in this solution.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.GeometryImplementation","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.GeometryImplementation","text":"Abstract type for event simulation implementation.\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.EventGeometry","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.EventGeometry","text":"An enum for possible event geometries (i.e. direct or reflected)\n\n\n\n\n\n","category":"type"},{"location":"simulate_jl/#CoRaLS.TrialFailed","page":"simulate.jl: The Main Cosmic Ray Simulation Script","title":"CoRaLS.TrialFailed","text":"An enum for possible reasons why the a cosmic ray trial failed.\n\n\n\n\n\n","category":"type"},{"location":"additional_details/#Additional-Details","page":"Additional Details","title":"Additional Details","text":"","category":"section"},{"location":"additional_details/","page":"Additional Details","title":"Additional Details","text":"This section of the documentation provides further information on contributing, frequently asked questions, the changelog, acknowledgments, and how to get support.","category":"page"},{"location":"additional_details/#Contributing","page":"Additional Details","title":"Contributing","text":"","category":"section"},{"location":"additional_details/","page":"Additional Details","title":"Additional Details","text":"Clone the CoRaLS repository \nCreate a new branch (or fork for larger changes)\nLocally make your changes\nCommit changes and push to your repository\nSubmit a pull request with a clear description of the changes.","category":"page"},{"location":"additional_details/#Unit-Testing","page":"Additional Details","title":"Unit Testing","text":"","category":"section"},{"location":"additional_details/","page":"Additional Details","title":"Additional Details","text":"Unit testing is currently in development. In the test directory, you can find the current test files. The basicunittests.jl file contains unit testing for constants.jl, geometry.jl, fresnel.jl and ice.jl. Testing for the remaining files is in progress. When files are completed they can be added to the runtests.jl file. ","category":"page"},{"location":"additional_details/","page":"Additional Details","title":"Additional Details","text":"You can run all completed tests by executing include(\"test/runtests.jl\");","category":"page"},{"location":"additional_details/#FAQs","page":"Additional Details","title":"FAQs","text":"","category":"section"},{"location":"additional_details/#Q:-Where-can-I-find-examples-of-CoRaLS-in-use?","page":"Additional Details","title":"Q: Where can I find examples of CoRaLS in use?","text":"","category":"section"},{"location":"additional_details/","page":"Additional Details","title":"Additional Details","text":"A: Check out the Tutorials section for detailed examples and use cases.","category":"page"},{"location":"additional_details/#Acknowledgments-and-References","page":"Additional Details","title":"Acknowledgments and References","text":"","category":"section"},{"location":"additional_details/#Contact-and-Support","page":"Additional Details","title":"Contact and Support","text":"","category":"section"},{"location":"modules_used_by_acceptance/#Modules-used-in-acceptance.jl","page":"Modules Used by acceptance.jl","title":"Modules used in acceptance.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Several modules are utilized by acceptance.jl to perform its tasks. This section provides documentation for these modules.","category":"page"},{"location":"modules_used_by_acceptance/#Constants","page":"Modules Used by acceptance.jl","title":"Constants","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"c_0: The speed of light in vacuum, defined as 2.99792458 × 10^8 meters per second.\nμ_0: The magnetic constant (also known as the permeability of free space), valued at approximately 1.25663706212 × 10^-6 henrys per meter.\nk_b: Boltzmann's constant, used in statistical mechanics and thermodynamics, with a value of about 8.617333 × 10^-5 electronvolts per kelvin.","category":"page"},{"location":"modules_used_by_acceptance/#cosmic_ray.jl","page":"Modules Used by acceptance.jl","title":"cosmic_ray.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"This file deals with modeling and analysis of cosmic rays. It includes functions to estimate key parameters of cosmic ray interactions, such as the depth of shower maximum (Xmax), and to propagate cosmic rays to their point of maximum interaction. The file also provides tools to model the charge excess profile of cosmic ray-induced air showers.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.estimate_Xmax\nCoRaLS.propagate_to_Xmax\nCoRaLS.charge_excess_profile","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.estimate_Xmax","page":"Modules Used by acceptance.jl","title":"CoRaLS.estimate_Xmax","text":"estimate_Xmax(Ecr::Unitful.Quantity)\n\nEstimate the mean and variation in Xmax for a given cosmic ray energy Ecr.\n\nXmax is the maximum depth in the atmosphere where a cosmic ray-induced air shower reaches its peak intensity. This function uses the Auger fits to Xmax and σ(Xmax) from:     https://www.icrc2019.org/uploads/1/1/9/0/         119067782/yushkovaugericrc2019mass1talk_final.pdf\n\nThis is only valid up to 1e20.5 (VERIFY THIS).\n\nArguments\n\nEcr: Energy of the cosmic ray in EeV.\n\nReturns\n\nTuple of (mean, sigma) of Xmax in g/cm^2.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.propagate_to_Xmax","page":"Modules Used by acceptance.jl","title":"CoRaLS.propagate_to_Xmax","text":"propagate_to_Xmax(origin, direction, Ecr, densitymodel)\n\nPropagate a cosmic ray from the surface to its shower maximum (Xmax).\n\nThis function calculates the point of shower maximum based on the cosmic ray's energy and direction, considering the density model of the medium through which it propagates.\n\nArguments\n\norigin: Starting point of the cosmic ray.\ndirection: Direction vector of the cosmic ray.\nEcr: Energy of the cosmic ray.\ndensitymodel: Model of the density of the medium.\n\nReturns\n\nThe position vector where the cosmic ray reaches Xmax.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.charge_excess_profile","page":"Modules Used by acceptance.jl","title":"CoRaLS.charge_excess_profile","text":"charge_excess_profile(Ecr::Unitful.Quantity)\n\nReturn the profile of excess shower charge (in Coulombs) for a cosmic ray of energy Ecr.\n\nThis function calculates the charge profile based on parameters derived from ZHAireS simulations of cosmic ray air showers.\n\nArguments\n\nEcr: Energy of the cosmic ray in EeV.\n\nReturns\n\nFunction Q(z) that evaluates the shower charge profile at a given distance z.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#fresnel.jl","page":"Modules Used by acceptance.jl","title":"fresnel.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Fresnel reflections and transmissions related to cosmic ray detection. It includes abstract types for divergence models and specific implementations for different divergence scenarios. It also contains functions for calculating Fresnel reflection and transmission coefficients and their modifications for spherical wave divergence at the surface.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.DivergenceModel\nCoRaLS.FarFieldDivergence\nCoRaLS.fresnel_coeffs\nCoRaLS.divergence_tperp","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.DivergenceModel","page":"Modules Used by acceptance.jl","title":"CoRaLS.DivergenceModel","text":"Abstract type for a divergence model for surface refraction.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.FarFieldDivergence","page":"Modules Used by acceptance.jl","title":"CoRaLS.FarFieldDivergence","text":"Far-field (spherical) divergence.\n\nThis is taken from the FORTE paper.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.fresnel_coeffs","page":"Modules Used by acceptance.jl","title":"CoRaLS.fresnel_coeffs","text":"fresnel_coeffs(θi, ni, nt; simple_t = true)\n\nCalculate the parallel and perpendicular Fresnel reflection and transmission  coefficients. \n\nEach coefficient is the ratio of reflected/transmitted to incident amplitude (denoted r and t, not to be confused with fresnel coefficients for power, R and T)\n\nIf simplet is true (default) then the transmission coefficients are calculated as follows, otherwise they use the full Fresnel equations.     tparallel = ni * (rparallel + 1) / nt     tperpendicular = r_perpendicular + 1\n\nArguments\n\nθi: Incident angle.\nni: Refractive index of the initial medium.\nnt: Refractive index of the transmitting medium.\n\nReturns\n\n(rpar, rperp, tpar, tperp): Fresnel coefficients.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.divergence_tperp","page":"Modules Used by acceptance.jl","title":"CoRaLS.divergence_tperp","text":"divergence_tperp(::FarFieldDivergence, θ_i, n, Drego, Dvacuum)\n\nCalculate modified Fresnel transmission coefficients for the perpendicular polarization, considering far-field (spherical) divergence of waves at the surface.\n\nArguments\n\nθ_i: Incident angle.\nn: Refractive index of the medium.\nDrego: Distance through regolith.\nDvacuum: Distance through vacuum.\n\nReturns\n\nModified Fresnel transmission coefficient for perpendicular polarization.\n\nNote: We construct this so that it can be directly multiplied to an electric field, so have to back out the total distance, before doing the scaling.\n\nNote: Since the refraction occurs in the near field (Fresnel region), the standard far-field (i.e. spherical) divergence assumption in the FORTE paper doesn't hold. Our current model for this is an additional factor of n (which boosts the transmission).\n\nSee the FORTE paper, Appendix 2, for more details. arXiV:0309656\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#geometry.jl","page":"Modules Used by acceptance.jl","title":"geometry.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Contains functions for modeling the geometry of cosmic ray interactions with the lunar surface. This includes functions to calculate the horizon angle, random vectors, and spherical cap areas, as well as functions to convert between spherical and Cartesian coordinates and to intersect rays with spheres.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.Rmoon\nCoRaLS.random_north_pole_point\nCoRaLS.random_south_pole_point\nCoRaLS.random_angles_on_cap\nCoRaLS.random_point_on_cap\nCoRaLS.spherical_to_cartesian\nCoRaLS.cartesian_to_spherical\nCoRaLS.horizon_angle\nCoRaLS.random_vector\nCoRaLS.random_direction\nCoRaLS.spherical_cap_area\nCoRaLS.intersect_with_sphere\nCoRaLS.propagate_and_refract","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.Rmoon","page":"Modules Used by acceptance.jl","title":"CoRaLS.Rmoon","text":"Spherical approximation to the polar radius of the Moon.\n\nNote: PG's MC had 1736.0km - TODO check.\n\n\n\n\n\n","category":"constant"},{"location":"modules_used_by_acceptance/#CoRaLS.random_north_pole_point","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_north_pole_point","text":"random_north_pole_point()\n\nDraw a random point on the North lunar pole\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.random_south_pole_point","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_south_pole_point","text":"random_south_pole_point()\n\nDraw a random point on the South lunar pole\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.random_angles_on_cap","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_angles_on_cap","text":"Generate a (theta, phi) pair on a spherical cap uniformly in solid angle.\n\nAll angles are in radians.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.random_point_on_cap","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_point_on_cap","text":"Sample a random point on a spherical cap uniformly in solid angle.\n\nWe assume that the spherical cap is centered on the +z-pole of the sphere.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.spherical_to_cartesian","page":"Modules Used by acceptance.jl","title":"CoRaLS.spherical_to_cartesian","text":"Convert a spherical point (theta, phi, r) into Cartesian coordinates.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.cartesian_to_spherical","page":"Modules Used by acceptance.jl","title":"CoRaLS.cartesian_to_spherical","text":"Convert a cartesian point (x, y, z) into a spherical point (theta, phi, r).\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.horizon_angle","page":"Modules Used by acceptance.jl","title":"CoRaLS.horizon_angle","text":"horizon_angle(altitude; R=Rmoon)\n\nCalculate the angle below the horizontal of the horizon from a given altitude.\n\nThis returns \"negative\" angles, in radians, for \"below\" the horizontal.\n\nArguments\n\nheight: The altitude above the surface (with units).`\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.random_vector","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_vector","text":"random_vector()\n\nGenerate a random Cartesian direction distributed uniformly on the unit-sphere with the pole of the sphere aligned with normal\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.random_direction","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_direction","text":"random_direction()\n\nGenerate a random Cartesian direction distributed uniformly on the unit-sphere with the pole of the sphere aligned with normal weighted by cos^2(\theta)\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.spherical_cap_area","page":"Modules Used by acceptance.jl","title":"CoRaLS.spherical_cap_area","text":"spherical_cap_area(theta, r=Rmoon)\n\nCalculate the area of a spherical cap with central angle theta.\n\nReturned units will be the square of the units of r.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.intersect_with_sphere","page":"Modules Used by acceptance.jl","title":"CoRaLS.intersect_with_sphere","text":"intersect_with_sphere(start, direction, radius)\n\nPropagate a vector from start to radius along direction.\n\nAssumes direction is normalized.\n\nSee the below link for the formalism behind this implementation:     https://www.scratchapixel.com/lessons/3d-basic-rendering/         minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.propagate_and_refract","page":"Modules Used by acceptance.jl","title":"CoRaLS.propagate_and_refract","text":"propagate_and_refract(start, antenna, direction, scale, indexmodel)\n\nPropagate from start along direction to antenna, shifting direction by scale along the normal using the indexmodel for the refractive index.\n\nThis function is for use during minimization of the refractive ray path and is not intended for public use (the API may change).\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#ice.jl","page":"Modules Used by acceptance.jl","title":"ice.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Models the surface roughness of ice, which is a critical factor in simulating the reflection and transmission of radio waves on ice surfaces. It includes abstract and concrete types representing different models of ice roughness and functions to apply these models to simulated electric fields.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.IceRoughnessModel\nCoRaLS.NoIceRoughness\nCoRaLS.GaussianIceRoughness\nCoRaLS.ice_roughness\nCoRaLS.ice_roughness","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.IceRoughnessModel","page":"Modules Used by acceptance.jl","title":"CoRaLS.IceRoughnessModel","text":"ice.jl\n\nModels the surface roughness of ice, which is a critical factor in simulating the reflection and transmission of radio waves on ice surfaces. It includes abstract and concrete types representing different models of ice roughness and functions to apply these models to simulated electric fields.\n\nMain Components\n\nIceRoughnessModel: An abstract type for general ice roughness models.\nNoIceRoughness: A model representing no surface roughness (smooth ice).\nGaussianIceRoughness: A model representing Gaussian ice surface roughness, characterized by a standard deviation of surface angles.\nice_roughness: Functions to apply roughness models to electric fields, modifying them based on the specified roughness model.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.NoIceRoughness","page":"Modules Used by acceptance.jl","title":"CoRaLS.NoIceRoughness","text":"NoIceRoughness <: IceRoughnessModel\n\nRepresents a model of ice surface with no roughness (smooth surface). This model assumes a perfectly smooth ice surface, affecting the reflection and transmission of radio waves accordingly.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.GaussianIceRoughness","page":"Modules Used by acceptance.jl","title":"CoRaLS.GaussianIceRoughness","text":"GaussianIceRoughness(σ::typeof(0.0cm)) <: IceRoughnessModel\n\nA model representing Gaussian ice surface roughness, characterized by a standard deviation (σ) of the angular distribution of the surface.\n\nArguments\n\nσ: Standard deviation of the surface angles, representing the degree of roughness.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.ice_roughness","page":"Modules Used by acceptance.jl","title":"CoRaLS.ice_roughness","text":"ice_roughness(model::IceRoughnessModel, ν, E, θ_i)\n\nApply the specified ice roughness model to a simulated electric field. The function modifies the electric field based on the roughness characteristics of the model.\n\nArguments\n\nmodel: An instance of IceRoughnessModel to apply.\nν: Frequencies of the electric field.\nE: Electric field amplitudes.\nθ_i: Angle of incidence at the ice surface.\n\nReturns\n\nModified frequencies and electric field based on the roughness model. If the model is NoIceRoughness, the function returns the given frequencies and electric field. If the model is GaussianIceRoughness, the function modifies the electric field based on the \"Diffuse reflection by rough surfaces: an introduction\" by Sylvain, Pg. 671.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#moon.jl","page":"Modules Used by acceptance.jl","title":"moon.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Contains functionality related to lunar geography, specifically focusing on permanently shadowed regions (PSRs) on the moon's surface. It includes functions to calculate the visible area of PSRs from a given altitude, convert geographical coordinates to stereographic projections, and determine if a surface point impacts a PSR.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.psr_area\nCoRaLS.psr_fraction\nCoRaLS.latlon_to_xy\nCoRaLS.point_impacts_psr","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.psr_area","page":"Modules Used by acceptance.jl","title":"CoRaLS.psr_area","text":"psr_area(altitude)\n\nCalculate the total area of lunar permanently shadowed regions (PSRs) that are observable from a given altitude.\n\nArguments\n\naltitude: Altitude of the observing instrument above the lunar surface.\n\nReturns\n\nTotal area of PSRs visible from the given altitude.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.psr_fraction","page":"Modules Used by acceptance.jl","title":"CoRaLS.psr_fraction","text":"psr_fraction(altitude)\n\nDetermine the fraction of the observable lunar surface at a given altitude that is covered by PSRs.\n\nArguments\n\naltitude: Altitude of the observing instrument above the lunar surface.\n\nReturns\n\nFraction of the observable area covered by PSRs.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.latlon_to_xy","page":"Modules Used by acceptance.jl","title":"CoRaLS.latlon_to_xy","text":"latlon_to_xy(::LunarPole, lat, lon)\n\nConvert latitude and longitude coordinates into (x, y) coordinates based on stereographic projections for either the North or South Pole.\n\nArguments\n\n::LunarPole: Specify NorthPole or SouthPole.\nlat: Latitude in degrees.\nlon: Longitude in degrees.\n\nReturns\n\n(x, y): Coordinates in meters in the respective pole's stereographic projection.\n\nFormulas from: http://pds.lroc.asu.edu/data/LRO-L-LROC-5-RDR-V1.0/LROLRC_2001/DOCUMENT/RDRSIS.PDF\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.point_impacts_psr","page":"Modules Used by acceptance.jl","title":"CoRaLS.point_impacts_psr","text":"point_impacts_psr(surface)\n\nCheck if a point on the lunar surface impacts a permanently shadowed region (PSR).\n\nArguments\n\nsurface: A point on the lunar surface.\n\nReturns\n\ntrue if the point impacts a PSR, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#plots.jl","page":"Modules Used by acceptance.jl","title":"plots.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Visualization Tools for CoRaLS Simulation Data","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.plot_incident_angles\nCoRaLS.plot_polarization_angle\nCoRaLS.plot_offaxis_angle\nCoRaLS.plot_acceptance\nCoRaLS.plot_differential_spectrum\n","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.plot_incident_angles","page":"Modules Used by acceptance.jl","title":"CoRaLS.plot_incident_angles","text":"plot_incident_angles(AΩ::Acceptance)\n\nPlot the incident angles at the ice and the surface for both direct and reflected events, along with the corresponding Fresnel coefficients.\n\nArguments:\n\nAΩ::Acceptance: An object containing the acceptance calculation results.\n\nGenerates a two-part plot. The left plot shows histograms of incident angles at the surface for direct and reflected events. The right plot shows incident angles at the ice layer for reflected events. Behind these histograms, the function plots the transmission and reflection coefficients as a function of the incident angle.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.plot_polarization_angle","page":"Modules Used by acceptance.jl","title":"CoRaLS.plot_polarization_angle","text":"plot_polarization_angle(AΩ::Acceptance)\n\nPlot histograms of polarization angles for direct and reflected events.\n\nArguments:\n\nAΩ::Acceptance: An object containing the acceptance calculation results.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.plot_offaxis_angle","page":"Modules Used by acceptance.jl","title":"CoRaLS.plot_offaxis_angle","text":"plot_offaxis_angle(AΩ::Acceptance)\n\nGenerate a plot showing the off-axis angle distribution of direct and reflected events in the CoRaLS simulations.\n\nArguments:\n\nAΩ::Acceptance: An object containing the acceptance calculation results.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.plot_acceptance","page":"Modules Used by acceptance.jl","title":"CoRaLS.plot_acceptance","text":"plot_acceptance(AΩ::Acceptance)\n\nPlot the direct and reflected acceptance of the CoRaLS project.\n\nArguments:\n\nAΩ::Acceptance: An object containing the acceptance calculation results.\n\nThis function generates a line plot illustrating the acceptance rates for both direct and reflected events across different energy levels.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.plot_differential_spectrum","page":"Modules Used by acceptance.jl","title":"CoRaLS.plot_differential_spectrum","text":"plot_differential_spectrum(AΩ::Acceptance, T::Unitful.Time)\n\nCreate a plot of the differential event spectrum of CoRaLS events given an acceptance object and a mission duration.\n\nArguments:\n\nAΩ::Acceptance: An object containing the acceptance calculation results.\nT::Unitful.Time: The total observation time of the experiment.\n\nThis function plots the estimated number of events per energy bin over the duration of the mission.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#regolith.jl","page":"Modules Used by acceptance.jl","title":"regolith.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Contains functions for modeling the regolith of the lunar surface. This includes abstract and concrete types representing different models of regolith density and functions to apply these models to simulated electric fields.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.regolith_density\nCoRaLS.create_density_lut\nCoRaLS.regolith_index\nCoRaLS.RegolithIndex\nCoRaLS.ConstantIndex\nCoRaLS.SurfaceDeepIndex\nCoRaLS.StrangwayIndex\nCoRaLS.RegolithDensity\nCoRaLS.ConstantDensity\nCoRaLS.StrangwayDensity\nCoRaLS.OldIncorrectDensity\n","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.regolith_density","page":"Modules Used by acceptance.jl","title":"CoRaLS.regolith_density","text":"regolith_density(::ConstantDensity, depth)\n\nCalculate the density of the regolith in g/cm^3.\n\n\n\n\n\nregolith_density(::OldIncorrectDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth.\n\n\n\n\n\nregolith_density(::StrangwayDensity, depth)\n\nCalculate the density of the regolith in g/cm^3 for depth using the Olhoeft & Strangway curve.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.create_density_lut","page":"Modules Used by acceptance.jl","title":"CoRaLS.create_density_lut","text":"create_density_lut(N)\n\nCreate a LUT of the density as a function of depth using \"Curve A\" from Olhoeft & Strangway. N is the number of points in the LUT.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.regolith_index","page":"Modules Used by acceptance.jl","title":"CoRaLS.regolith_index","text":"regolith_index(::ConstantIndex, depth)\n\nA constant refractive index as a function of depth.\n\n\n\n\n\nregolith_index(::SurfaceDeepIndex, depth)\n\nA two-part \"surface\" and \"deep\" refractive index model.\n\n\n\n\n\nregolith_index(::StrangwayIndex, depth)\n\nA refractive index model from Olhoeft & Strangway.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.RegolithIndex","page":"Modules Used by acceptance.jl","title":"CoRaLS.RegolithIndex","text":"Abstract type for regolith index models.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.ConstantIndex","page":"Modules Used by acceptance.jl","title":"CoRaLS.ConstantIndex","text":"Constant regolith refractive index.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.SurfaceDeepIndex","page":"Modules Used by acceptance.jl","title":"CoRaLS.SurfaceDeepIndex","text":"A \"surface\" and \"deep\" regolith model.\n\nThis uses a small refractive index at the surface and a larger one for below the surface.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.StrangwayIndex","page":"Modules Used by acceptance.jl","title":"CoRaLS.StrangwayIndex","text":"A refractive index model from Olhoeft & Strangway.\n\nThis uses Eq. 1 from Olhoeft and Strangway.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.RegolithDensity","page":"Modules Used by acceptance.jl","title":"CoRaLS.RegolithDensity","text":"Abstract type for regolith density models.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.ConstantDensity","page":"Modules Used by acceptance.jl","title":"CoRaLS.ConstantDensity","text":"Constant regolith density\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.StrangwayDensity","page":"Modules Used by acceptance.jl","title":"CoRaLS.StrangwayDensity","text":"A regolith density model from Olhoeft & Strangway.\n\nThis is \"Curve A\" from O&S.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.OldIncorrectDensity","page":"Modules Used by acceptance.jl","title":"CoRaLS.OldIncorrectDensity","text":"A logarithmic regolith density model from PG's ARIA MC.\n\nThis is WRONG - do NOT use this except when trying to reproduce or evaluate results from early August 2021.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#spectrum.jl","page":"Modules Used by acceptance.jl","title":"spectrum.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.sample_power_law\nCoRaLS.auger_spectrum\nCoRaLS.sample_auger","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.sample_power_law","page":"Modules Used by acceptance.jl","title":"CoRaLS.sample_power_law","text":"sample_power_law(gamma; min_value, max_value)\n\nDraw random samples from a power law with exponent gammma.\n\nIf provided, min_value and max_value set the range over which the power-law is sampled (defaults to 1 EeV and 1000 EeV)\n\nThis uses the prescription from:     https://mathworld.wolfram.com/RandomNumber.html to convert a uniform deviate into a power law with a given exponent.\n\n\n\n\n\nsample_power_law(gamma, N; min_value, max_value)\n\nDraw N random samples from a power law with exponent gammma.\n\nIf provided, min_value and max_value set the range over which the power-law is sampled (defaults to 1 EeV and 1000 EeV)\n\nThis uses the prescription from:     https://mathworld.wolfram.com/RandomNumber.html to convert a uniform deviate into a power law with a given exponent.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.auger_spectrum","page":"Modules Used by acceptance.jl","title":"CoRaLS.auger_spectrum","text":"Evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1.\n\nThis uses the parameterization from:     https://academic.oup.com/ptep/article/2017/12/12A103/4665686\n\n\n\n\n\nRandomly evaluate the Auger UHECR spectrum in eV^-1 km^-2 sr^-1 yr^-1 within experimental uncertainties.\n\nThis method differs from the one argument version of auger_spectrum() in that it randomly samples the parameters within experimental uncertainties so that you can capture the variation in the cosmic ray spectrum.\n\nThis uses the parameterization from:     https://academic.oup.com/ptep/article/2017/12/12A103/4665686\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.sample_auger","page":"Modules Used by acceptance.jl","title":"CoRaLS.sample_auger","text":"sample_auger(min_energy, max_energy)\n\nDraw a random sample from the Auger UHECR flux between min_energy and max_energy.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#surface.jl","page":"Modules Used by acceptance.jl","title":"surface.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Contains functions for modeling surface roughness and slope. This includes the Gaussian roughness and slope models, as well as functions to generate random surface normals and calculate surface transmission.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.RoughnessModel\nCoRaLS.NoRoughness\nCoRaLS.GaussianRoughness\nCoRaLS.SlopeModel\nCoRaLS.NoSlope\nCoRaLS.GaussianSlope\nCoRaLS.random_surface_normal\nCoRaLS.surface_transmission","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.RoughnessModel","page":"Modules Used by acceptance.jl","title":"CoRaLS.RoughnessModel","text":"Abstract type for regolith surface roughness model.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.NoRoughness","page":"Modules Used by acceptance.jl","title":"CoRaLS.NoRoughness","text":"No surface roughness (smooth)\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.GaussianRoughness","page":"Modules Used by acceptance.jl","title":"CoRaLS.GaussianRoughness","text":"Gaussian surface roughness model.\n\nThis is characterized by Gaussian \"sigma\" of the angular distribution of the surface.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.SlopeModel","page":"Modules Used by acceptance.jl","title":"CoRaLS.SlopeModel","text":"Abstract type for regolith surface slope model.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.NoSlope","page":"Modules Used by acceptance.jl","title":"CoRaLS.NoSlope","text":"No surface slope (smooth)\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.GaussianSlope","page":"Modules Used by acceptance.jl","title":"CoRaLS.GaussianSlope","text":"Gaussian surface slope model.\n\nThis is characterized by Gaussian \"sigma\" of the angular distribution of the surface in degrees.\n\n\n\n\n\n","category":"type"},{"location":"modules_used_by_acceptance/#CoRaLS.random_surface_normal","page":"Modules Used by acceptance.jl","title":"CoRaLS.random_surface_normal","text":"random_surface(slope::NoSlope, normal)\n\nGenerate a random normal vector for a surface slope that would originally be pointing along normal in the absence of roughness.\n\nThis just returns normal since this implements a \"No Slope\" model.\n\n\n\n\n\nrandom_surface(slope::GaussianSlope, normal)\n\nGenerate a random normal vector for a surface slope that would originally be pointing along normal in the absence of roughness.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.surface_transmission","page":"Modules Used by acceptance.jl","title":"CoRaLS.surface_transmission","text":"surface_transmission(::NoRoughness, ν, E, θ_i)\n\nApply roughness to a simulated electric field given the frequencies, the electric field, and the angle of incidence at the surface. This returns the frequencies and electric field back to the caller.\n\nWithout roughness, we just return ν and E as given.\n\n\n\n\n\nsurface_transmission(::GaussianRoughness, ν, E, θ_i)\n\nApply a simple model for surface transmission through a rough surface by taking the average of the transmission coefficient over the Gaussian\n\nThis is based on the \"Diffuse reflection by rough surfaces: an introduction\" by Sylvain, Pg. 671\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#trigger.jl","page":"Modules Used by acceptance.jl","title":"trigger.jl","text":"","category":"section"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"Contains functions describing the trigger mechanisms for cosmic ray detection. This includes the magnitude trigger, Gaussian trigger, and Rician trigger.","category":"page"},{"location":"modules_used_by_acceptance/","page":"Modules Used by acceptance.jl","title":"Modules Used by acceptance.jl","text":"CoRaLS.magnitude_trigger\nCoRaLS.gaussian_trigger\nCoRaLS.rician_trigger","category":"page"},{"location":"modules_used_by_acceptance/#CoRaLS.magnitude_trigger","page":"Modules Used by acceptance.jl","title":"CoRaLS.magnitude_trigger","text":"magnitude_trigger(peak=67μV/m; dν=10.0MHz)\n\nCreate a trigger function that checks if the total magnitude of the electric field is greater than some threshold.\n\nArguments\n\npeak=67μV/m: The threshold for the electric field's magnitude.\ndν=10.0MHz: Frequency step size.\n\nReturns\n\nA function that checks if the norm of the electric field of an event is greater than the threshold.\n\nDescription\n\nThis function generates a trigger function that evaluates whether the total magnitude of the electric field for a cosmic ray event exceeds a specified threshold. The electric field magnitude is calculated as the product of the field's polarization norm, frequency step size, and sum of electric field components.\n\nUsage\n\nUsed to filter events based on the strength of their electric field magnitude, allowing selection of significant cosmic ray events.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.gaussian_trigger","page":"Modules Used by acceptance.jl","title":"CoRaLS.gaussian_trigger","text":"gaussian_trigger(peak=67μV/m, σ=45.0; dν=10.0MHz, θ0=-90.)\n\nCreates a Gaussian beam threshold pointing down towards the nadir     with peak threshold at the nadir and a width of σ in degrees. This uses the current estimate for a sinuous antenna array by P. Gorham\n\nArguments\n\npeak=67μV/m: Peak threshold of the electric field at the nadir.\nσ=45.0: Width of the Gaussian beam in degrees.\ndν=10.0MHz: Frequency step size.\nθ0=-90.: Nadir angle in degrees.\n\nReturns\n\nA function that checks if an event's electric field, after being scaled by a Gaussian factor based on its off-axis angle, exceeds the peak threshold.\n\nDescription\n\nThis trigger function incorporates a Gaussian beam pattern, scaling the threshold for the electric field magnitude based on the event's off-axis angle relative to the nadir. The Gaussian factor decreases the effective threshold as the angle increases from the nadir.\n\nUsage\n\nUseful in scenarios where the sensitivity of detection varies with the angle of incident cosmic rays, simulating a realistic antenna response.\n\n\n\n\n\n","category":"function"},{"location":"modules_used_by_acceptance/#CoRaLS.rician_trigger","page":"Modules Used by acceptance.jl","title":"CoRaLS.rician_trigger","text":"rician_trigger(;snr_threshold=5.0, bw=900.0MHz, peak=calculated, σ=45.0)\n\nCreate a Rician beam trigger function based on signal-to-noise ratio.\n\nParameters\n\nsnr_threshold=5.0: The signal-to-noise ratio threshold for triggering.\nbw=900.0MHz: Bandwidth for the trigger.\npeak=calculated: Peak threshold calculated based on the provided parameters.\nσ=45.0: Width of the Gaussian beam in degrees.\n\nReturns\n\nA trigger function that evaluates if the signal-to-noise ratio of an event's electric field exceeds the specified threshold.\n\nDescription\n\nThis trigger function calculates a scaled threshold based on the event's off-axis angle and evaluates if the event's electric field, subjected to a Rician distributed noise model, surpasses this threshold. The function accounts for both primary and subsurface reflections.\n\nUsage\n\nIdeal for more sophisticated detection scenarios where the signal-to-noise ratio plays a crucial role in determining event significance.\n\n\n\n\n\n","category":"function"},{"location":"all_remaining_modules/#All-Remaining-Modules","page":"All Remaining Modules","title":"All Remaining Modules","text":"","category":"section"},{"location":"all_remaining_modules/","page":"All Remaining Modules","title":"All Remaining Modules","text":"This section covers all other modules in the CoRaLS package that have not been documented in the previous sections.","category":"page"},{"location":"all_remaining_modules/","page":"All Remaining Modules","title":"All Remaining Modules","text":"detector.jl,\nraytrace.jl,\nsimulate_vector.jl,\nsky.jl,\ntoy.jl,\nutils.jl","category":"page"},{"location":"acceptance_jl/#acceptance.jl:-The-Main-Monte-Carlo-Loop","page":"acceptance.jl: The Main Monte Carlo Loop","title":"acceptance.jl: The Main Monte Carlo Loop","text":"","category":"section"},{"location":"acceptance_jl/","page":"acceptance.jl: The Main Monte Carlo Loop","title":"acceptance.jl: The Main Monte Carlo Loop","text":"The acceptance.jl is part of the CoRaLS module and contains functions and structures for calculating the acceptance of the system for sub-surface Ultra-High-Energy Cosmic Ray (UHECR) reflections from ice. It also includes utilities for analyzing trials and computing differential spectra.","category":"page"},{"location":"acceptance_jl/#Main-Components","page":"acceptance.jl: The Main Monte Carlo Loop","title":"Main Components","text":"","category":"section"},{"location":"acceptance_jl/","page":"acceptance.jl: The Main Monte Carlo Loop","title":"acceptance.jl: The Main Monte Carlo Loop","text":"CoRaLS.Acceptance\nCoRaLS.acceptance\nCoRaLS.trials_passed\nCoRaLS.differential_spectrum","category":"page"},{"location":"acceptance_jl/#CoRaLS.Acceptance","page":"acceptance.jl: The Main Monte Carlo Loop","title":"CoRaLS.Acceptance","text":"A structure to hold results of acceptance calculations, including trials, altitude, energies, and different acceptance types (direct and reflected).\n\n\n\n\n\n","category":"type"},{"location":"acceptance_jl/#CoRaLS.acceptance","page":"acceptance.jl: The Main Monte Carlo Loop","title":"CoRaLS.acceptance","text":"acceptance(ntrials, nbins; ...)\n\nCalculates the acceptance of CoRaLS for sub-surface UHECR reflections. It involves simulations of cosmic ray interactions, triggering conditions, and aggregating results across multiple trials and energy bins.\n\n\n\n\n\n","category":"function"},{"location":"acceptance_jl/#CoRaLS.trials_passed","page":"acceptance.jl: The Main Monte Carlo Loop","title":"CoRaLS.trials_passed","text":"trials_passed\n\nCalculate the number of successful trials in the direct and reflected acceptances.\n\n\n\n\n\n","category":"function"},{"location":"acceptance_jl/#CoRaLS.differential_spectrum","page":"acceptance.jl: The Main Monte Carlo Loop","title":"CoRaLS.differential_spectrum","text":"differential_spectrum(energies, AΩ, T)\n\nCalculate the differential spectrum of detected UHECR events based on acceptance calculations and T, the total observation time of the experiment.\n\nCalculates the differential spectrum of detected UHECR events .\n\n\n\n\n\n","category":"function"},{"location":"intro_to_julia/#Introduction-to-Julia","page":"Introduction to Julia","title":"Introduction to Julia","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Welcome to the Julia programming language! This guide is designed for physicists who are familiar with Python and are new to Julia. Here, we'll cover an introduction to Julia, its pros and cons, and how it compares to Python. Additionally, we'll offer tips and tricks useful for beginners.","category":"page"},{"location":"intro_to_julia/#Introduction-to-Julia-2","page":"Introduction to Julia","title":"Introduction to Julia","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Julia is a high-level, high-performance dynamic programming language for technical computing. It was designed to address the needs of high-performance numerical analysis and computational science, without the trade-offs typically required by other languages. Julia provides a sophisticated compiler, distributed parallel execution, numerical accuracy, and an extensive mathematical function library.","category":"page"},{"location":"intro_to_julia/#General-Pros-and-Cons-of-Julia","page":"Introduction to Julia","title":"General Pros and Cons of Julia","text":"","category":"section"},{"location":"intro_to_julia/#Pros","page":"Introduction to Julia","title":"Pros","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Performance: Julia's JIT (Just-In-Time) compiler enables it to run high-performance computing tasks efficiently. It's designed to approach and often match the speed of C for many tasks.\nEase of Use: Julia combines the simplicity of Python with the power of languages like C and Fortran.\nDynamic Type System: Offers the flexibility of scripts with the power of statically typed languages.\nRich Ecosystem for Scientific Computing: Extensive standard libraries and packages for various scientific domains.\nParallel and Distributed Computing: Built-in support for parallel and distributed computing.","category":"page"},{"location":"intro_to_julia/#Cons","page":"Introduction to Julia","title":"Cons","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Young Ecosystem: While growing rapidly, Julia's ecosystem is not as mature as Python's, with fewer libraries and resources available.\nLearning Curve: For those used to object-oriented programming, Julia's focus on functional programming and multiple dispatch can take some getting used to.\nCompilation Time: The JIT compilation process can introduce delays in script execution, especially noticeable in short scripts or during development.","category":"page"},{"location":"intro_to_julia/#Julia-vs.-Python:-Differences-and-Similarities","page":"Introduction to Julia","title":"Julia vs. Python: Differences and Similarities","text":"","category":"section"},{"location":"intro_to_julia/#Differences","page":"Introduction to Julia","title":"Differences","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Performance: Julia generally offers superior performance due to its JIT compilation.\nSyntax and Design Philosophy: Julia uses multiple dispatch as a core design concept, which allows functions to behave differently based on the types of their inputs.\nParallel Computing: Julia was designed with parallelism in mind, providing more straightforward and integrated support for parallel operations.","category":"page"},{"location":"intro_to_julia/#Similarities","page":"Introduction to Julia","title":"Similarities","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Ease of Learning: Both languages have an easy-to-learn syntax and are popular among scientists and engineers.\nInteractive Environments: Like Python's Jupyter Notebooks, Julia can be used in Jupyter Notebooks, allowing for an interactive programming experience.\nOpen Source: Both languages are open source and have active communities contributing to their development.","category":"page"},{"location":"intro_to_julia/#Tips-and-Tricks-for-Using-Julia","page":"Introduction to Julia","title":"Tips and Tricks for Using Julia","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Use Julia's Package Manager: Julia's package manager, Pkg, is powerful and easy to use. Take advantage of it to manage dependencies.\nLeverage Multiple Dispatch: Learn and leverage multiple dispatch, which allows defining function behavior across many combinations of argument types.\nPrecompile Your Code: To avoid JIT compilation times during development, consider using the @time macro to identify slow parts of your code and precompile modules when possible.\nUtilize the Julia Community: The Julia community is welcoming and resourceful. Engage with community forums and resources for learning materials and support.","category":"page"},{"location":"intro_to_julia/#Additional-Resources-for-Beginners","page":"Introduction to Julia","title":"Additional Resources for Beginners","text":"","category":"section"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Julia Documentation: The official Julia documentation is a comprehensive resource.\nJulia Discourse: A forum for questions and discussions on Julia.\nJuliaHub: A portal for Julia packages, documentation, and more.","category":"page"},{"location":"intro_to_julia/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Transitioning to Julia from Python can be a rewarding experience, offering performance improvements and new programming paradigms. Happy coding!","category":"page"},{"location":"corals_jl_overview/#The-CoRaLS.jl-Overview","page":"The CoRaLS.jl Overview","title":"The CoRaLS.jl Overview","text":"","category":"section"},{"location":"corals_jl_overview/","page":"The CoRaLS.jl Overview","title":"The CoRaLS.jl Overview","text":"The CoRaLS (Cosmic Ray Lunar Sounder) module is designed for analyzing and simulating cosmic ray interactions, particularly in lunar contexts. It provides a comprehensive toolkit for modeling cosmic ray paths, energy spectra, and their interactions with lunar regolith and other materials.","category":"page"},{"location":"corals_jl_overview/#Included-Files-and-Their-Purpose","page":"The CoRaLS.jl Overview","title":"Included Files and Their Purpose","text":"","category":"section"},{"location":"corals_jl_overview/","page":"The CoRaLS.jl Overview","title":"The CoRaLS.jl Overview","text":"simulate.jl: Contains simulation tools and models for cosmic ray interactions, detector responses, and other related phenomena.\ndetector.jl: Focuses on models and functions related to cosmic ray detectors, including their design, response, and data analysis.\nacceptance.jl: Provides tools for calculating the acceptance of cosmic ray detectors, an essential factor in understanding and comparing detector efficiencies.\nconstants.jl: Defines a comprehensive set of constants used across the module. This may include physical constants, lunar parameters, and other universally applicable values.\nutils.jl: Provides utility functions that support various operations throughout the module. These might include mathematical helpers, data formatting functions, or common computational routines.\ngeometry.jl: Contains functions related to geometric calculations and transformations, crucial for modeling and simulating spatial relationships and paths in cosmic ray studies.\nspectrum.jl: Offers models and functions for spectral analysis, particularly for analyzing the energy spectrum of cosmic rays and other astrophysical phenomena.\ncosmic_ray.jl: Dedicated to modeling and simulating cosmic ray behavior, including their generation, propagation, and interactions with different materials.\nfresnel.jl: Implements Fresnel equations and related calculations, typically used for understanding wave propagation and reflection.\nice.jl: Focuses on the properties and behaviors of ice, especially in extraterrestrial environments, which is essential in certain cosmic ray detection scenarios.\nsky.jl: Contains models or functions related to the study of the sky, possibly including sky background radiation calculations or celestial body temperature models.\nregolith.jl: Addresses the properties of lunar regolith, such as its density and refractive index, and how these properties affect cosmic ray measurements.\nefield.jl: Deals with electric field calculations and models, particularly in the context of cosmic ray detection and lunar surface interactions.\ntrigger.jl: Provides various triggering mechanisms for detecting cosmic rays or other relevant events, crucial in data acquisition systems.\nmoon.jl: Offers functions specific to lunar studies, including calculations related to the moon's surface, environment, and its interactions with cosmic rays.\nraytrace.jl: Implements ray tracing algorithms, an important tool in visualizing and analyzing the paths of cosmic rays and other radiation.\nsurface.jl: Includes models and functions related to surface properties, which might be critical in understanding detector-environment interactions.\nplots.jl: Offers a suite of plotting and visualization tools tailored for representing data and results from cosmic ray studies and related simulations.","category":"page"},{"location":"getting_started/#Getting-Started-with-CoRaLS","page":"Getting Started","title":"Getting Started with CoRaLS","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After successfully installing CoRaLS, this guide will help you get started with using the CoRaLS environment for your simulations.","category":"page"},{"location":"getting_started/#Using-the-CoRaLS-Environment","page":"Getting Started","title":"Using the CoRaLS Environment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once you have completed the initial build of PyCall and imported the CoRaLS code, subsequent uses of CoRaLS will be more straightforward and quicker.","category":"page"},{"location":"getting_started/#Activating-the-CoRaLS-Environment","page":"Getting Started","title":"Activating the CoRaLS Environment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To begin, activate the CoRaLS environment each time you start a new session:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Enter the package mode in Julia's REPL by pressing ].\nActivate the CoRaLS environment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"pkg> activate .\npkg> instantiate","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Exit package mode by pressing backspace","category":"page"},{"location":"getting_started/#Importing-CoRaLS","page":"Getting Started","title":"Importing CoRaLS","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using CoRaLS","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once you have executed this command, CoRaLS is loaded into your Julia session, and you are ready to run functions and scripts specific to CoRaLS.","category":"page"},{"location":"getting_started/#Running-a-Test","page":"Getting Started","title":"Running a Test","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To verify that CoRaLS is working as expected, you can run a simple test:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"  julia> CoRaLS.plot_acceptance(CoRaLS.acceptance(10000, 20))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can also run some of the test scripts in the test directory to verify that CoRaLS is working as expected. First, navigate to the test directory and run the test scripts:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> include(\"test/test_acceptance.jl\")\njulia> include(\"test/test_simulation.jl\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If the tests pass, you can be confident that CoRaLS is working as expected.","category":"page"},{"location":"#CoRaLS-Documentation","page":"Home","title":"CoRaLS Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for CoRaLS (Cosmic Ray Localization System), an astrophysics and particle physics simulation software written in Julia.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoRaLS Documentation\nContents\nIntroduction\nInstallation\nGetting Started\nTutorials\nAPI Reference\nGuides for Physicists New to Julia\nAdditional Details","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoRaLS is designed to provide researchers and students in astrophysics and particle physics with a robust tool for simulation and analysis. This section covers an overview of the software, its purpose, and a quick start guide.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Step-by-step instructions on how to install and configure CoRaLS, including system requirements.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic examples and use cases to help new users get started with CoRaLS.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In-depth tutorials covering various aspects and functionalities of CoRaLS.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comprehensive documentation of all functions, classes, and modules in CoRaLS, automatically generated from docstrings.","category":"page"},{"location":"#Guides-for-Physicists-New-to-Julia","page":"Home","title":"Guides for Physicists New to Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A resource for physicists familiar with Python but new to Julia, highlighting the key differences and similarities, along with best practices.","category":"page"},{"location":"#Additional-Details","page":"Home","title":"Additional Details","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributing: How to contribute to the CoRaLS project.\nFAQs: Frequently asked questions.\nAcknowledgments and References: Credits and scientific references.\nContact and Support: Information on how to get help and contact the development team.","category":"page"}]
}
